
import json, re, os, sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from langchain.schema import HumanMessage, SystemMessage
from agent.custome_agent import MyCustomMultiImageChatLLM
from utils.helper_functions import parse_llm_response_pydantic
import logging
from utils.schemas import LLMComplianceResult
from typing import List, Dict, Optional, Any

class old_Reports():

    def __init__(self, control_number, list_image_paths, controls_content, api):
        """
        Initializes the Reports class with control number and image paths.

        Args:
            control_number (str): The control number to be included in the report.
            list_image_paths (list): A list of image file paths to be included in the report.
            controls_content (str): full text of merged_controls.py
        """
        self.control_number = control_number
        self.list_image_paths = list_image_paths
        self.endpoint_url = api
        self.controls_content = controls_content

    def generate_report(self):
        """
        Generates a report based on the provided control number and image paths.
        
        Args:
            control_number (str): The control number to be included in the report.
            image_paths (list): A list of image file paths to be included in the report.
            
        Returns:
            str: The generated report content.
        """
        endpoint_url = self.endpoint_url
        llm = MyCustomMultiImageChatLLM(endpoint_url=endpoint_url)

        # control_content = getattr(self.controls, 'control'+ self.control_number)
        pattern = rf'{self.control_number.strip()}\s*=\s*\"\"\"(.*?)\"\"\"'
        match = re.search(pattern, self.controls_content, re.DOTALL)

        if not match:
            raise ValueError(f"Control {self.control_number} not found in uploaded content.")

        control_content = match.group(1).strip()

        image_files = self.list_image_paths
        
        response = llm.invoke([HumanMessage(content=control_content)], image_paths=image_files)
        #print(response.content)
        return response.content

    def final_output_handling_parsing(self):
        """
        Extracts structured compliance information from the report generated by Images_report().

        Returns:
            dict: {
                "compliance": str,
                "flags": list,
                "needs_review": bool,
                "Brief_report": str,
                "report": str
            }
        """
        report_text = self.generate_report()

        # Instruction using proper JSON Schema style
        schema_instruction = (
            "The output should be formatted as a JSON instance that conforms to the JSON schema below.\n\n"
            "As an example, for the schema "
            '{"properties": {"foo": {"title": "Foo", "description": "a list of strings", "type": "array", "items": {"type": "string"}}}, "required": ["foo"]},\n'
            "the object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema.\n"
            "The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\n"
            "Here is the output schema:\n"
            "```\n"
            '{\n'
            '  "type": "object",\n'
            '  "properties": {\n'
            '    "compliance_status": {\n'
            '      "type": "string",\n'
            '      "description": "Compliance status: one of COMPLIANT, NON-COMPLIANT, INDECISIVE"\n'
            '    },\n'
            '    "flags": {\n'
            '      "type": "array",\n'
            '      "items": {"type": "string"},\n'
            '      "description": "List of issues or missing requirements"\n'
            '    },\n'
            '    "Brief_report": {\n'
            '      "type": "string",\n'
            '      "description": "Short summary of compliance analysis"\n'
            '    },\n'
            '    "needs_human_review": {\n'
            '      "type": "boolean",\n'
            '      "description": "Whether human review is needed"\n'
            '    }\n'
            '  },\n'
            '  "required": ["compliance_status", "flags", "Brief_report", "needs_human_review"]\n'
            '}\n'
            "```\n\n"
            f"Report:\n{report_text}"
        )

        print(f"[Instruction Sent to LLM]\n{schema_instruction}\n")

        llm = MyCustomMultiImageChatLLM(endpoint_url=self.endpoint_url)

        try:
            image_files = self.list_image_paths
            print(f"[Image Files]: {image_files}")
            
            # invoke model
            response = llm.invoke([HumanMessage(content=schema_instruction)], image_paths=image_files)
            print(f"[LLM Raw Response]: {response}")

            # Parse using your parsing function
            info = parse_llm_response_pydantic(response.content, report_text)

            # Return structured result
            return {
                "compliance": info.get("compliance_status", ""),
                "flags": info.get("flags", []),
                "needs_review": info.get("needs_human_review", False),
                "Brief_report": info.get("Brief_report", ""),
                "report": report_text
            }

        except Exception as e:
            print(f"[Error during report handling]: {e}")
            return {
                "error": str(e),
                "report": report_text
            }




class Reports:
    def __init__(
        self,
        user_message: str,
        language: str,
        control_number: str,
        list_image_paths: List[str],
        controls_content: Dict,
        api: Optional[str] = None
    ):
        """
        Args:
            control_number (str): ID for the control.
            list_image_paths (List[str]): Paths to images to be sent to the LLM.
            controls_content (Dict): Structured control data.
            api (str): LLM API endpoint.
        """
        self.user_message = user_message
        self.language = language
        self.control_number = control_number
        self.image_paths = list_image_paths
        self.api = api

        # Extract structured content
        self.title = controls_content.get("title", "")
        self.description_control = controls_content.get("description_control", "")
        self.audit_instructions = controls_content.get("audit_instructions", "")
        self.clause_audit_instructions = controls_content.get("clause_audit_instructions", "")
        self.llm = MyCustomMultiImageChatLLM(endpoint_url=self.api)

        # Cache generated report
        self.report_text: Optional[str] = None

        # Map Arabic LLM outputs to English for validation
        self.STATUS_MAP = {
            "ممتثل": "COMPLIANT",
            "غير ممتثل": "NON-COMPLIANT",
            "غير حاسم": "INDECISIVE"
        }

        self.NATURAL_MAP_EN = {
            "COMPLIANT": "ممتثل",
            "NON-COMPLIANT": "غير ممتثل",
            "INDECISIVE": "غير حاسم"
        }

    def build_control_context(self) -> str:
        """Formats the control information for the LLM."""
        return (
            f"User Message: {self.user_message}"
            f"Control Number: {self.control_number}\n"
            f"Title: {self.title}\n"
            f"Description:\n{self.description_control}\n"
            f"Audit Instructions:\n{self.audit_instructions}\n"
        )


    def clean_llm_json(self, content: str) -> str:
        content = (content or "").strip()
        if content.startswith("```"):
            content = content.split("```json")[-1].split("```")[0].strip()
        return content


    def translate_to_arabic(self, text: str) -> str:
        """Translate English text to Arabic using LLM."""
        # Minimal call to LLM to translate
        try:
            prompt = f"Translate the following text to Arabic clearly and concisely:\n{text}"
            response = self.llm.invoke([HumanMessage(content=prompt)], language="ar")
            return response.content.strip()
        except Exception:
            logging.exception("Translation failed; returning original text.")
            return text


    def translate_if_needed(self, data, language: str):
        """
        Dynamically translates a string or list of strings into Arabic if needed.
        Keeps English if user language is not Arabic.
        """
        # If not Arabic, return as-is
        if not language.lower().startswith("ar"):
            return data

        def needs_translation(text: str) -> bool:
            """Check if text is mostly English/ASCII letters."""
            return any(c.isalpha() and c.isascii() for c in text)

        # Handle list of strings (flags)
        if isinstance(data, list):
            translated_list = []
            for item in data:
                translated_list.append(
                    self.translate_to_arabic(item) if needs_translation(item) else item
                )
            return translated_list

        # Handle single string
        if isinstance(data, str):
            return self.translate_to_arabic(data) if needs_translation(data) else data

        # Fallback: return data as-is
        return data
    

    def batch_translate_to_arabic(self, compliance: str, flags: list[str], brief_report: str) -> tuple[str, list[str], str]:
        """
        Translates compliance, flags, and brief_report to natural Arabic in a single LLM call.
        Returns a tuple (translated_compliance, translated_flags, translated_brief_report).
        """
        try:
            # Prepare JSON for LLM
            original_data = {
                "compliance": compliance,
                "flags": flags,
                "brief_report": brief_report
            }

            prompt = f"""
            Translate the following JSON fields to Arabic naturally and concisely
            as if explaining a compliance report to a human.
            Keep JSON keys the same, return only JSON.

            JSON to translate:
            {json.dumps(original_data, ensure_ascii=False, indent=2)}
            """

            response = self.llm.invoke([HumanMessage(content=prompt)], language="ar")
            translated_content = self.clean_llm_json(response.content)

            translated_json = json.loads(translated_content)

            return (
                translated_json.get("compliance", compliance),
                translated_json.get("flags", flags),
                translated_json.get("brief_report", brief_report),
            )
        except Exception:
            logging.exception("Batch translation failed; returning original values.")
            return compliance, flags, brief_report


    def generate_and_parse_report(self) -> dict:
        """
        Generates a compliance report using the LLM and immediately parses it
        into a structured JSON object according to the defined schema.
        """
        try:
            # 1️⃣ Generate report if not cached
            if not self.report_text:
                messages = [
                    SystemMessage(content=self.clause_audit_instructions),
                    HumanMessage(content=self.build_control_context())
                ]
                response = self.llm.invoke(
                    messages,
                    image_paths=self.image_paths,
                    language=self.language
                )
                self.report_text = response.content

            # 2️⃣ Parse report to structured JSON
            schema_instruction = f"""
            Return a JSON object conforming to the following schema:

            {{
            "compliance_status": one of:
                - "COMPLIANT" (English) / "ممتثل" (Arabic)
                - "NON-COMPLIANT" (English) / "غير ممتثل" (Arabic)
                - "INDECISIVE" (English) / "غير حاسم" (Arabic)
                
            "flags": ["List of detected issues or notes in the user-selected language"],
            "Brief_report": "Short summary of the compliance evaluation in the user-selected language",
            "needs_human_review": true | false
            }}

            ⚡ Notes:
            - compliance_status must be in English for validation.
            - flags and Brief_report must be in {self.language} only.
            - If the original issue is in English and language is Arabic, translate it to Arabic.
            - Output only the JSON object without explanations.

            Report:
            {self.report_text}
            """

            parse_response = self.llm.invoke(
                [HumanMessage(content=schema_instruction)],
                image_paths=self.image_paths,
                language=self.language
            )

            # 3️⃣ Clean & parse JSON
            raw_content = self.clean_llm_json(parse_response.content)
            if not raw_content:
                raise RuntimeError("LLM returned an empty response.")

            raw_info = json.loads(raw_content)

            # 4️⃣ Normalize compliance status for validation
            status = self.STATUS_MAP.get(
                raw_info.get("compliance_status", "").strip(),
                raw_info.get("compliance_status", "")
            )

            info = LLMComplianceResult.model_validate({
                **raw_info,
                "compliance_status": status
            })

            # 5️⃣ Translate to Arabic only if user selected Arabic
            is_arabic = self.language.lower().startswith("ar")

            compliance = info.compliance_status
            compliance_natural = self.NATURAL_MAP_EN.get(compliance, compliance)
            flags = info.flags
            brief_report = info.Brief_report

            if is_arabic:
                compliance, flags, brief_report = self.batch_translate_to_arabic(
                    compliance_natural, flags, brief_report
                )

            return {
                "compliance": compliance,
                "flags": flags,
                "needs_review": info.needs_human_review,
                "Brief_report": brief_report,
                "report": self.report_text
            }

        except Exception as e:
            logging.exception("Error in generating and parsing report.")
            return {"error": str(e), "report": self.report_text}


    def combine_image_results(self, data: List[Dict[str, Any]]) -> Dict[str, Any]:
        combined_flags = []
        combined_brief = []
        combined_report = []
        overall_status = "COMPLIANT"
        needs_review = False
        

        for item in data:
            status = str(item["compliance"])
            if status == "ComplianceStatus.NON_COMPLIANT":
                overall_status = "NON-COMPLIANT"
            elif status == "ComplianceStatus.INDECISIVE" and overall_status != "NON-COMPLIANT":
                overall_status = "INDECISIVE"

            combined_flags.extend(item.get("flags", []))
            combined_brief.append(item.get("Brief_report", ""))
            combined_report.append(item.get("report", ""))
            if item.get("needs_review"):
                needs_review = True

        return {
            "compliance": overall_status,
            "flags": combined_flags,
            "Brief_report": "\n".join(combined_brief),
            "needs_review": needs_review,
            "report": "\n".join(combined_report)

        }


    def run_full_pipeline(self) -> dict:
        """
        Convenience method: runs report generation + parsing.

        Returns:
            dict: Final structured output with report.
        """
        # self.generate_report()
        return self.generate_and_parse_report()

    def run_full_pipeline_ids(self) -> List[dict]:
        """
        Runs the full pipeline for each image and returns structured results for all.
        """
        results = []

        for idx, image_path in enumerate(self.image_paths):
            self.report_text = ""  # Reset before each image
            self.image_paths = [image_path]  # Process one image at a time

            try:
                parsed = self.generate_and_parse_report()
                results.append({
                    "id": idx,
                    "image_name": os.path.basename(image_path),
                    **parsed
                })
            except Exception as e:
                results.append({
                    "id": idx,
                    "image_name": os.path.basename(image_path),
                    "error": str(e)
                })

        return results
